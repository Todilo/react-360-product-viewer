{"version":3,"file":"stories-React360Viewer-stories.aae38e2c.iframe.bundle.js","mappings":";;;;;AAkBA;;;;;;;ACHA;AAEA;AACA;AACA;AACA;;AAGA;;;;;;;AC4BA;;AAIA;;;AAMA","sources":["webpack://react-360-product-viewer/./src/components/AnimationImage/AnimationImage.tsx","webpack://react-360-product-viewer/./src/components/icons/StyledRotateIcon.tsx","webpack://react-360-product-viewer/./src/components/React360Viewer/React360Viewer.tsx"],"sourcesContent":["import React from \"react\";\nimport styled from \"styled-components\";\n\ninterface ImageProps {\n  src: string;\n  isVisible: boolean;\n  width: number;\n  height: number;\n}\n\ninterface StyledImageProps {}\nconst StyledImage = styled.img<StyledImageProps>`\n  user-select: none;\n  touch-action: none;\n  cursor: inherit;\n  -webkit-user-drag: none;\n`;\n\nconst AnimationImage = ({ src, isVisible, width, height }: ImageProps) => {\n  let d = isVisible ? \"block\" : \"none\";\n  return (\n    <StyledImage\n      alt=\"Rotating object\"\n      src={src}\n      width={width}\n      height={height}\n      style={{ display: `${d}` }}\n    ></StyledImage>\n  );\n};\n\nexport default AnimationImage;\n","import RotateIcon from \"./RotateIcon\";\nimport styled, { css } from \"styled-components\";\n\ntype StyledRotateIconProps = {\n  widthInEm: number;\n  isReverse: boolean;\n};\n\nconst StyledRotateIcon = styled(RotateIcon)<StyledRotateIconProps>`\n  position: absolute;\n\n  fill: #eee;\n  text-shadow: 4px 5px black;\n  filter: drop-shadow(3px 3px 2px rgba(0, 0, 0, 0.7));\n  opacity: 0.8;\n  ${(props) =>\n    css`\n      top: calc(50% - ${props.widthInEm / 2}em);\n      left: calc(50% - ${props.widthInEm / 2}em);\n      width: ${props.widthInEm}em;\n      transform: scaleX(${props.isReverse ? \"-1\" : \"1\"});\n    `};\n`;\nexport default StyledRotateIcon;\n","import React, { useEffect, useRef, useState } from \"react\";\nimport styled, { css } from \"styled-components\";\nimport AnimationImage from \"../AnimationImage/AnimationImage\";\nimport StyledRotateIcon from \"../icons/StyledRotateIcon\";\nimport type { HtmlHTMLAttributes, ReactNode } from \"react\";\n\n// The regular % can return negative numbers.\nfunction moduloWithoutNegative(value: number, n: number): number {\n  return ((value % n) + n) % n;\n}\n\nexport type ZeroPadRange = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\n\nexport interface React360ViewerProps {\n  imagesCount: number;\n  imagesBaseUrl: string;\n  imageIndexSeparator?: string;\n  imagesFiletype: string;\n  imageFilenamePrefix: string;\n  imageInitialIndex?: number;\n  mouseDragSpeed?: number;\n  autoplaySpeed?: number;\n  reverse?: boolean;\n  autoplay?: boolean;\n  autoplayTarget?: number;\n  width?: number;\n  height?: number;\n  zeroPad?: ZeroPadRange;\n  showRotationIconOnStartup?: boolean;\n  customRotationIcon?: () => ReactNode;\n  notifyOnPointerDown?: (x: number, y: number) => void;\n  notifyOnPointerUp?: (x: number, y: number) => void;\n  notifyOnPointerMoved?: (x: number, y: number) => void;\n  shouldNotifyEvents?: boolean;\n}\n\n/** Base props *and* all available HTML div element props. */\nexport type React360ViewerPropsExtended = HtmlHTMLAttributes<HTMLDivElement> &\n  React360ViewerProps;\n\ninterface StyleProps {\n  isGrabbing: boolean;\n}\n\nconst StyledDiv = styled.div<StyleProps>`\n  position: relative;\n  border: none;\n  padding: 5px;\n  display: inline-block;\n  user-select: none;\n  touch-action: none;\n  ${(props) =>\n    props.isGrabbing\n      ? css`\n          cursor: grabbing;\n        `\n      : css`\n          cursor: pointer;\n        `};\n`;\n\nexport const React360Viewer = ({\n  imagesCount,\n  imagesBaseUrl,\n  imageIndexSeparator,\n  imagesFiletype,\n  imageFilenamePrefix,\n  mouseDragSpeed = 20,\n  reverse = false,\n  autoplaySpeed = 10,\n  autoplay = false,\n  autoplayTarget,\n  width = 150,\n  height = 150,\n  zeroPad = 0,\n  showRotationIconOnStartup = false,\n  customRotationIcon,\n  imageInitialIndex = 0,\n  shouldNotifyEvents = false,\n  notifyOnPointerDown,\n  notifyOnPointerUp,\n  notifyOnPointerMoved,\n}: React360ViewerPropsExtended) => {\n  const elementRef = useRef(null);\n  const [isScrolling, setIsScrolling] = useState(false);\n  const [initialMousePosition, setInitialMousePosition] = useState(0);\n  const [startingImageIndexOnPointerDown, setStartingImageIndexOnPointerDown] =\n    useState(0);\n  const [currentMousePosition, setCurrentMousePosition] = useState(0);\n  const [selectedImageIndex, setSelectedImageIndex] = useState(0);\n  const [imageSources, setImageSources] = useState<\n    Array<{ src: string; index: string }>\n  >([]);\n\n  const [showRotationIcon, setShowRotationIcon] = useState(\n    showRotationIconOnStartup\n  );\n  const [useAutoplay, setUseAutoplay] = useState(autoplay);\n  useEffect(() => {\n    setUseAutoplay(autoplay);\n\n    setShowRotationIcon(!autoplay && showRotationIconOnStartup);\n  }, [autoplay, showRotationIconOnStartup]);\n\n  useEffect(() => {\n    if (typeof imageInitialIndex === \"undefined\") return;\n    if (imageInitialIndex < 0 || imageInitialIndex >= imagesCount) {\n      setSelectedImageIndex(imageInitialIndex);\n      console.log(\n        `ImageInitialIndex of ${imageInitialIndex} was out of bounds of 0 and count: ${imagesCount}`\n      );\n    }\n\n    setSelectedImageIndex(imageInitialIndex);\n  }, [imageInitialIndex, imagesCount]);\n\n  useEffect(() => {\n    if (!useAutoplay) return;\n\n    const timer = setTimeout(() => {\n      incrementImageIndex(1);\n    }, 1000 / autoplaySpeed);\n\n    return () => clearTimeout(timer);\n  });\n\n  const incrementImageIndex = (change: number) => {\n    let index = moduloWithoutNegative(\n      selectedImageIndex + (reverse ? -1 : 1) * Math.floor(change),\n      imagesCount\n    );\n\n    setSelectedImageIndex(index);\n\n    if (autoplayTarget !== undefined && index === autoplayTarget) {\n      setUseAutoplay(false);\n    }\n  };\n\n  useEffect(() => {\n    function createImageSources() {\n\n      let baseUrl;\n\n      if (imageIndexSeparator !== undefined) {\n        baseUrl = imagesBaseUrl + imageIndexSeparator;\n      } else {\n        baseUrl = imagesBaseUrl.endsWith(\"/\")\n          ? imagesBaseUrl\n          : imagesBaseUrl + \"/\";\n      };\n\n      let srces = [];\n      let fileType = imagesFiletype.replace(\".\", \"\");\n      for (let i = 1; i <= imagesCount; i++) {\n        srces.push({\n          src: `${baseUrl}${imageFilenamePrefix ? imageFilenamePrefix : \"\"}${!!zeroPad ? String(i).padStart(zeroPad + 1, \"0\") : i\n            }.${fileType}`,\n          index: i.toString(),\n        });\n      }\n      return srces;\n    }\n    setImageSources(createImageSources());\n  }, [\n    imagesBaseUrl,\n    imagesFiletype,\n    imagesCount,\n    imageFilenamePrefix,\n    zeroPad,\n  ]);\n\n  const onMouseDown = (e: React.MouseEvent) => {\n    setInitialMousePosition(e.clientX);\n    setCurrentMousePosition(e.clientX);\n    setStartingImageIndexOnPointerDown(selectedImageIndex);\n    setUseAutoplay(false);\n    setIsScrolling(true);\n    setShowRotationIcon(false);\n\n    document.addEventListener(\n      \"mouseup\",\n      () => {\n        onMouseUp();\n      },\n      { once: true }\n    );\n\n    if (shouldNotifyEvents) notifyOnPointerDown?.(e.clientX, e.clientY);\n  };\n\n  const onMouseUp = (e?: React.MouseEvent) => {\n    setIsScrolling(false);\n\n    if (!shouldNotifyEvents) return;\n\n    if (typeof e !== \"undefined\") notifyOnPointerUp?.(e?.clientX, e.clientY);\n    else {\n      notifyOnPointerUp?.(0, 0);\n    }\n  };\n\n  const onMouseMove = (e: React.MouseEvent) => {\n    if (!isScrolling) return;\n\n    setCurrentMousePosition(e.clientX);\n\n    if (shouldNotifyEvents) notifyOnPointerMoved?.(e.clientX, e.clientY);\n  };\n\n  useEffect(() => {\n    const imageIndexWithOffset = (start: number, offset: number) => {\n      let index = moduloWithoutNegative(\n        start + (reverse ? -1 : 1) * Math.floor(offset),\n        imagesCount\n      );\n      setSelectedImageIndex(index);\n    };\n\n    if (!isScrolling) return;\n\n    // Aim is to get a speedfactor that can be easily adjusted from a user perspective\n    // as well as proportionate to the size of the image.\n    const scaleFactor = 100;\n    let speedFactor =\n      (1 / mouseDragSpeed) * ((imagesCount * width) / scaleFactor);\n    const changeInX = currentMousePosition - initialMousePosition;\n\n    let difference = changeInX / speedFactor;\n\n    imageIndexWithOffset(startingImageIndexOnPointerDown, difference);\n  }, [\n    currentMousePosition,\n    imagesCount,\n    startingImageIndexOnPointerDown,\n    initialMousePosition,\n    isScrolling,\n    mouseDragSpeed,\n    width,\n    height,\n    reverse,\n  ]);\n\n  return (\n    <StyledDiv\n      ref={elementRef}\n      isGrabbing={isScrolling}\n      onPointerDown={onMouseDown}\n      // onPointerUp={onMouseUp}\n      onPointerMove={onMouseMove}\n    // onMouseDown={onMouseDown}\n    // onMouseMove={onMouseMove}\n    >\n      {showRotationIcon ? (\n        <>\n          {\n            customRotationIcon ? (\n              <>{customRotationIcon()}</>\n            ) : (\n              <StyledRotateIcon widthInEm={2} isReverse={reverse}></StyledRotateIcon>\n            )\n          }\n        </>\n      ) : null}\n      {imageSources.map((s, index) => (\n        <AnimationImage\n          src={s.src}\n          width={width}\n          height={height}\n          isVisible={index === selectedImageIndex}\n          key={index}\n        ></AnimationImage>\n      ))}\n    </StyledDiv>\n  );\n};\n"],"names":[],"sourceRoot":""}